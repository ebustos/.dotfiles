There are a few things I don't understand from your question, such as which foldmethod you are using, or what the number of "rows" refers to, but here's a custom foldtext function that should do roughly what you want:

function! MyFoldText()
    let nl = v:foldend - v:foldstart + 1
    let comment = substitute(getline(v:foldstart),"^ *","",1)
    let linetext = substitute(getline(v:foldstart+1),"^ *","",1)
    let txt = '+ ' . linetext . ' : "' . comment . '" : length ' . nl
    return txt
endfunction
set foldtext=MyFoldText()
Explanation:

Find the number of lines contained by the fold.
Get the "comment" from the line before the first folded line (and remove leading spaces).
Get the text from the first line of the fold (and remove leading spaces).
Assemble the above information into the returned foldtext, with appropriate formatting.
Hope this helps. It should be easily tailored to your needs.






=====

f you want the fold text to be indented at the same level as the first line of the fold, you need to prepend the indent level to the foldtext:

function! MyFoldText()
    let indent_level = indent(v:foldstart)
    let indent = repeat(' ',indent_level)
    ...
    ...   
    return indent . txt
endfunction
Here I am assuming that the string txt is your existing foldtext, so all you need to do is add it to the end of indent.

But I am not sure if that is what you want to achieve.

EDIT:

Now I have seen your picture, I'm not sure if this is what you want. You could try stripping the leading whitespace before appending to the +. So the foldtext you want will be something like indent . '+' . txt.

Maybe.

---
For others looking this up, foldtext() is the function which returns the default foldtext. So return indent.foldtext() will return the default foldtext used but indented. Also, you need to type let foldtext=MyFoldText() somewhere for this custom function to be used. – Alexander Bird Aug 4 '11 at 14:10
1	  
just a tip for a special case: when I tried this using just getline(v:foldstart) in place of txt, the indentation was still a little off--the getline was adding 1 space per tab for some reason so I had to strip leading whitespace. Last line of the function now reads: return indent . substitute(getline(v:foldstart),'^\s*','','') – murftown Nov 1 '11 at 8:26
Awesome, this was exactly what I was looking for. – sporkbox Dec 23 '12 at 17:07


=====

Aha

You might want to comment out this function in your .vimrc:

set foldtext=MyFoldText()
set fillchars=fold:_
This is what makes your fold text appearing non default, by using the function:

function! MyFoldText()
  " setting fold text
  let nl = v:foldend - v:foldstart + 1
  let comment = substitute(getline(v:foldstart),"^ *\" *","",1)
  let linetext = substitute(getline(v:foldstart+1),"^ *","",1)
  let txt = '+ ' . comment . ': ' . nl .  ' ' . v:foldstart . '                                                                                                                                                                  '
  return txt
endfunction

===

I am trying to get the number of lines to show up on the right side of the screen, instead of near the left with the other text. Is this possible? My current .vimrc foldtext function concatenates the first two lines and keeps the current indent, followed by some dashes and then the number of lines:

function! MyFoldText()
    let line = getline(v:foldstart)
    let line2 = getline(v:foldstart + 1)
    let sub = substitute(line . "|" . line2, '/\*\|\*/\|{{{\d\=', '', 'g')
    let ind = indent(v:foldstart)
    let lines = v:foldend-v:foldstart + 1
    let i = 0
    let spaces = ''
    while i < (ind - ind/4)
        let spaces .= ' '
        let i = i+1
    endwhile
    return spaces . sub . ' --------(' . lines . ' lines)'
endfunction
So, using '|' as a screen edge, instead of

|    line1 | line2 --------(5 lines)-----------------|
the foldtext would be like this

|    line1 | line2 -------------------------(5 lines)|

p.s. It would also be nice to get a few extra fixes, such as pulling current tabstop setting instead of hardcoding it as 4, and getting it to show the next actual code (skipping comments, whitespace, brackets, etc), instead of just concatenating the first two lines.


======



I wanted to improve the standard Vim foldtext both to look better in GUI versions of Vim, and to make the folding work better with C-like languages (such as C++, Java and pov).
The foldtext function below does three things:

Is less intrusive when displaying code, and right-aligns the number of lines in the fold.
Collapses folds that start and end on braces with everything between the braces replaced with {...}.
Tries to collapse multiline comments with the first non-blank line in the comment.
Outstanding issues:
Right alignment may not work with signs turned on.
Tabs mess up the in-place display of the initial '{'.
" Set a nicer foldtext function
set foldtext=MyFoldText()
function! MyFoldText()
  let line = getline(v:foldstart)
  if match( line, '^[ \t]*\(\/\*\|\/\/\)[*/\\]*[ \t]*$' ) == 0
    let initial = substitute( line, '^\([ \t]\)*\(\/\*\|\/\/\)\(.*\)', '\1\2', '' )
    let linenum = v:foldstart + 1
    while linenum < v:foldend
      let line = getline( linenum )
      let comment_content = substitute( line, '^\([ \t\/\*]*\)\(.*\)$', '\2', 'g' )
      if comment_content != ''
        break
      endif
      let linenum = linenum + 1
    endwhile
    let sub = initial . ' ' . comment_content
  else
    let sub = line
    let startbrace = substitute( line, '^.*{[ \t]*$', '{', 'g')
    if startbrace == '{'
      let line = getline(v:foldend)
      let endbrace = substitute( line, '^[ \t]*}\(.*\)$', '}', 'g')
      if endbrace == '}'
        let sub = sub.substitute( line, '^[ \t]*}\(.*\)$', '...}\1', 'g')
      endif
    endif
  endif
  let n = v:foldend - v:foldstart + 1
  let info = " " . n . " lines"
  let sub = sub . "                                                                                                                  "
  let num_w = getwinvar( 0, '&number' ) * getwinvar( 0, '&numberwidth' )
  let fold_w = getwinvar( 0, '&foldcolumn' )
  let sub = strpart( sub, 0, winwidth(0) - strlen( info ) - num_w - fold_w - 1 )
  return sub . info
endfunction
I also use the following highlights with white backgrounded source to visually set the folds apart from non-folded lines, while trying to keep a nice aesthetic.
highlight FoldColumn  gui=bold    guifg=grey65     guibg=Grey90
highlight Folded      gui=italic  guifg=Black      guibg=Grey90
highlight LineNr      gui=NONE    guifg=grey60     guibg=Grey90



======

http://vim.wikia.com/wiki/Customize_text_for_closed_folds

===

function! NeatFoldText() "{{{2
  let line = ' ' . substitute(getline(v:foldstart), '^\s*"\?\s*\|\s*"\?\s*{{' . '{\d*\s*', '', 'g') . ' '
  let lines_count = v:foldend - v:foldstart + 1
  let lines_count_text = '| ' . printf("%10s", lines_count . ' lines') . ' |'
  let foldchar = matchstr(&fillchars, 'fold:\zs.')
  let foldtextstart = strpart('+' . repeat(foldchar, v:foldlevel*2) . line, 0, (winwidth(0)*2)/3)
  let foldtextend = lines_count_text . repeat(foldchar, 8)
  let foldtextlength = strlen(substitute(foldtextstart . foldtextend, '.', 'x', 'g')) + &foldcolumn
  return foldtextstart . repeat(foldchar, winwidth(0)-foldtextlength) . foldtextend
endfunction
set foldtext=NeatFoldText()

http://dhruvasagar.com/2013/03/28/vim-better-foldtext
